
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>C'est quoi cette histoire de shader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/basic.css">
  </head>
  <body>
    <div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> Q2 : un syst√®me solaire</div>
    <canvas id="webglcanvas" style="border: none;background-color:#000000"
	    width="800" height="600"></canvas>

    <script type="x-shader/x-vertex" id="vertexshader">

        attribute float size;

        varying vec3 vColor;

        void main() {

            vColor = color;

            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

            gl_PointSize = size * ( 300.0 / -mvPosition.z );

            gl_Position = projectionMatrix * mvPosition;

        }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

        uniform sampler2D pointTexture;

        varying vec3 vColor;

        void main() {

            gl_FragColor = vec4( vColor, 1.0 );

            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

        }

    </script>
    <script type="importmap">
      {
	  "imports": {
	      "three": "./three.module.js",
	      "three/addons/controls/": "./examples/jsm/controls/"
	  }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';

      const height = window.innerHeight;
      const width = window.innerWidth;

      var renderer = null;
      var scene    = null;
      var camera   = null;
      let particleSystem, uniforms, geometry;
      const particles = 100000;
      var group = null;
      var canvas = document.getElementById("webglcanvas");

      // Checks that your browser supports WebGL.
      if ( ! ( window.WebGLRenderingContext
	       && ( canvas.getContext('webgl')
		    || canvas.getContext('experimental-webgl')) ) )
	  console.log( "WebGL not supported on your browser." );

      init();
      run();

      // This function is called whenever the document is loaded
      function init() {

        // Create the Three.js renderer and attach it to our canvas
        renderer = new THREE.WebGLRenderer( { canvas: canvas,
                          antialias: true } );
        // Set the viewport size
        renderer.setSize( width, height );
        // Create a new Three.js scene
        scene = new THREE.Scene();
        // Add  a camera so we can view the scene
        camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 1000 );
        camera.position.z = 20;

        uniforms = {

          pointTexture: { value: new THREE.TextureLoader().load( 'images/spark1.png' ) }

        };

        const shaderMaterial = new THREE.ShaderMaterial( {

          uniforms: uniforms,
          vertexShader: document.getElementById( 'vertexshader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true

        } );


        const radius = 200;

        geometry = new THREE.BufferGeometry();

        const positions = [];
        const colors = [];
        const sizes = [];

        const color = new THREE.Color();

        for ( let i = 0; i < particles; i ++ ) {

          positions.push( ( Math.random() * 2 - 1 ) * radius );
          positions.push( ( Math.random() * 2 - 1 ) * radius );
          positions.push( ( Math.random() * 2 - 1 ) * radius );

          color.setHSL( i / particles, 1.0, 0.5 );

          colors.push( color.r, color.g, color.b );

          sizes.push( 20 );

        }

        geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
        geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
        geometry.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ).setUsage( THREE.DynamicDrawUsage ) );

        particleSystem = new THREE.Points( geometry, shaderMaterial );

        scene.add( particleSystem );

        const ambientlight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientlight);
      }

      // This function is called regularly to update the canvas webgl.
      function run() {
	  // Ask to call again run
	  requestAnimationFrame( run );

	  // Render the scene
	  render();

	  // Calls the animate function if objects or camera should move
	  animate();
      }

      // This function is called regularly to take care of the rendering.
      function render() {
	  // Render the scene
	  renderer.render( scene, camera );
      }

      // This function is called regularly to update objects.
      function animate() {
        //cube1.rotateX(0.1);
        //cube2.rotateX(0.1);
        //group.rotateZ(0.01);
        //requestAnimationFrame(animate);
        //renderer.render(scene, camera);
      }

    </script>

  </body>
</html>

